<html>
<head>
    <title>FractaLine by Nicusor</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #000000;
        }
    </style>
    <script src="pixi.js"></script>
    <script src="utils.js"></script>
</head>
<body onload="startScript();">
    <script>
    function startScript()
    {
        "use strict";
        //the code below is very ugly, please read carefully

        var WIDTH  = window.innerWidth;
        var HEIGHT = window.innerHeight;

        var drawingCanvas = document.createElement('canvas');
        drawingCanvas.width  = WIDTH;
        drawingCanvas.height = HEIGHT;
        var context = drawingCanvas.getContext('2d');

        var stage = new PIXI.Stage(0xe0ffff, true);

        //var renderer = new PIXI.CanvasRenderer(400, 300);
        var renderer  = new PIXI.CanvasRenderer(WIDTH, HEIGHT, null, false, true);
        // var context = renderer.context;
        

        var lineSprite = new PIXI.Sprite(PIXI.Texture.fromCanvas(drawingCanvas));
        stage.addChild(lineSprite);
        

        var recurLevel = 4;

        var linesGrph = new PIXI.Graphics();
        var recurGrph = new PIXI.Graphics();
        var gridGrph  = new PIXI.Graphics();
        var tempGrph  = new PIXI.Graphics();
        var numPoints = 5; //including start and finish
        var connect   = new Graph(numPoints+20);
        
        var direction;
        var gridDist = 20;

        //flags
        var Use_Grid = true;
        var Over_Objects = false;
        var Ctrl_Pressed = false;
        var Creating_Connection = {is: false, from: -1};
        var Draw_Points_Lines = true;
        var CHANGED = true;
        var canvasCode;
        var MIN_LINE_DIST = 3;
        var Over_Buttons = false;
        var Show_Display = true;

        // var polVect;
         
        document.body.appendChild(renderer.view);

    
        
        stage.addChild(gridGrph);
        stage.addChild(tempGrph);
        stage.addChild(linesGrph);
        stage.addChild(recurGrph);

        var text = new PIXI.Text("Recursion deepness: " + recurLevel, {font:"20px Arial", fill:"black"});
        stage.addChild(text);

        var about = new PIXI.Text("This is a very early version of the program\n \
there may be a lot of bugs\n \
press S and H to change to show or hide stuff\n \
press LEFT and RIGHT to increase/decrease recursion level",
            {font:"17px Arial", fill:"black"});
        stage.addChild(about);
        about.position.y = HEIGHT * 0.06;

        var GeneralDrawing = {
            //graph can be HTML5 canvas or PixiJS Graphics element
            drawGrid: function(graph, dist){
                graph.clear();
                graph.lineStyle(1, 0x111111, 0.2);

                var W = window.innerWidth;
                var H = window.innerHeight;
                var B = W > H ? W : H;

                for (var i=0; i<W; i+=dist)
                {

                    if (i % (dist * 5) == 0)
                        graph.lineStyle(2, 0x111111, 0.4);

                    graph.moveTo(0, i);
                    graph.lineTo(W, i);

                    graph.moveTo(i, 0);
                    graph.lineTo(i, H);

                    if (i % (dist * 5) == 0)
                        graph.lineStyle(1, 0x111111, 0.2);
                }
            },

            redrawArrows: function(graphics){
                if (!Show_Display) return;

                graphics.clear();
                graphics.alpha = 0.3;

                for (var i=0; i<connect.list1.length; ++i)
                    this.drawArrow(graphics, new Vector(points[ connect.list1[i].from ].x, points[ connect.list1[i].from ].y),
                                        new Vector(points[ connect.list1[i].to   ].x, points[ connect.list1[i].to   ].y));
                
            },

            drawArrow: function(graph, vec1, vec2){
                graph.beginFill();
                var dir = new Vector(vec2.x - vec1.x,
                                     vec2.y - vec1.y);

                var p1 = new Vector(0, 10);
                p1.ang += dir.ang + Math.PI/2;
                p1.x += vec1.x;
                p1.y += vec1.y;

                var p2 = new Vector(0, -10);
                p2.ang += dir.ang + Math.PI/2;
                p2.x += vec1.x;
                p2.y += vec1.y;

                var p3 = new Vector(vec2.x, vec2.y );

                graph.moveTo(p1.x, p1.y);
                graph.lineTo(p2.x, p2.y);
                graph.lineTo(p3.x, p3.y);

                graph.endFill();
            },
        }

        window.onresize = function(){
            WIDTH = window.innerWidth;
            HEIGHT = window.innerHeight;
            renderer.resize(WIDTH, HEIGHT);
        }

        GeneralDrawing.drawGrid(gridGrph, gridDist);


        // all the points
        var points = new Array(numPoints);
        points[0] = DR_Point(0x00ee00 , 100, 100, 0);
        points[1] = DR_Point(0xee0000, 1000, 100, 1);
        points[2] = DR_Point(0x000000, 400, 100 , 2);
        points[3] = DR_Point(0x000000, 550, 300 , 3);
        points[4] = DR_Point(0x000000, 700, 100 , 4);

        for (var i=0; i<numPoints; i++)
            stage.addChild(points[i]);
        // all the points

        connect.set2D(0, 2, 1);
        connect.set2D(2, 3, 1);
        connect.set2D(3, 4, 1);
        connect.set2D(4, 1, 1);

        requestAnimFrame( animate );

        function resetRecurText(){
            text.setText("Recursion deepness:  " + recurLevel);
        }

        function increaseRecurLevel(){
            ++recurLevel ;
            resetRecurText();
        }

        function decreaseRecurLevel(){
            if (--recurLevel < 1)
                recurLevel = 1;
            resetRecurText();
        }

        function resetNumbers()
        {
            for (var i=0; i<numPoints; ++i)
                points[i].number = i;
        }

        //The Buttons
            var tempH = 300;
            var createButton = MyButton(PIXI.Texture.fromImage("res/createButton.png"), "CREATE", 0, tempH + 0);
            var moveButton   = MyButton(PIXI.Texture.fromImage("res/moveButton.png")  , "MOVE"  , 0, tempH + 40);
            var deleteButton = MyButton(PIXI.Texture.fromImage("res/deleteButton.png"), "DELETE", 0, tempH + 80);
            var demoButton   = new PIXI.Sprite(PIXI.Texture.fromImage('res/demo.png'));
            demoButton.interactive = true;
            demoButton.buttonMode  = true;
            demoButton.position = {x:0, y:tempH + 120};
            demoButton.click = function(){
                window.open('http://www.youtube.com/watch?v=Bc9IHxqa64c');
            }
            stage.addChild(demoButton);

            //var minusButton  = MyButton

            var allButtons = [createButton, moveButton, deleteButton];
            var Action = "MOVE"; //CREATE, DELETE

            moveButton.click();
            

            stage.addChild(createButton);
            stage.addChild(moveButton);
            stage.addChild(deleteButton);
        //The Buttons

        function MyButton(texture, action, posx, posy){
            var nowButton = new PIXI.Sprite(texture);
            nowButton.position = {x: posx, y: posy};
            nowButton.interactive = true;
            nowButton.buttonMode  = true;
            nowButton.act = action;


            nowButton.unclick = function(){
                nowButton.clicked = false;
                nowButton.alpha = 0.5;
            }

            nowButton.mouseover = function(){
                console.log("in button" + nowButton.act);
                Over_Buttons = true;
                Over_Objects = true;
                if (!this.clicked)
                    this.alpha = 0.7;
            }
            nowButton.click = nowButton.tap = function(){
                if (!this.clicked)
                {
                    for (var i=0; i<allButtons.length; ++i)
                        allButtons[i].unclick();

                    Action = this.act;
                    this.clicked = true;
                    this.alpha = 1;
                }
            }
            nowButton.mouseout = function(){
                console.log("out button" + nowButton.act);
                Over_Buttons = false;
                Over_Objects = false;
                if (!this.clicked)
                    this.alpha = 0.5;
            }

            nowButton.unclick();

            return nowButton;
        }

        stage.click = function(e){
            console.log(Over_Objects);
            console.log(Over_Buttons);
            if (!Over_Objects)
            {
                if (Action === "CREATE")
                {
                    createNode(e.originalEvent.pageX, e.originalEvent.pageY);
                }
            }
        }

        document.onkeydown = function checkKey(e) {
            console.log(e.keyCode);

            e = e || window.event;

            if (e.keyCode == '72') {
                if (Use_Grid)
                {
                    Use_Grid = false
                    gridGrph.clear();
                }else{
                    GeneralDrawing.drawGrid(gridGrph, gridDist);
                    Use_Grid = true;
                }
            }else 
            if (e.keyCode == '17') {
                Ctrl_Pressed = true;
            }else
            if (e.keyCode == '32') {
                Draw_Points_Lines = !Draw_Points_Lines;
            }else
            if (e.keyCode == '39') {
                increaseRecurLevel();
                
                CHANGED = true;
            }else
            if (e.keyCode == '37') {
                decreaseRecurLevel();
                CHANGED = true;
            }else
            if (e.keyCode == '83') {
                showHideUI();
            }
        }

        function showHideUI(){
            var nowAlpha;
            Show_Display = !Show_Display;

            if (!Show_Display){
                nowAlpha = 0.01;
                linesGrph.clear();
            }
            else {
                nowAlpha = 0.6;
                GeneralDrawing.redrawArrows(linesGrph);
            }
            
                for (var i=0; i<points.length; ++i)
                {
                    points[i].normalAlpha = nowAlpha;
                    points[i].alpha = points[i].normalAlpha;

                }

        }

        function deleteNode(num){
            if (num > 1) { //if num is not start or end point
                connect.deleteElm(num);
                stage.removeChild(points[num]);
                points.splice(num, 1);
                numPoints--;
                resetNumbers();
            }
        }

        function createNode(posx, posy){
            points.push(DR_Point(0x000000, posx, posy, numPoints));
            stage.addChild(points[numPoints]);
            console.log(points[numPoints]);
            numPoints++;
        }

        document.onkeyup = function checkKey(e) {
            if (e.keyCode == '17') {
                Ctrl_Pressed = false;
            }
        }

        function setDragging(point) {

            point.mouseover = function(){
                Over_Objects = true;
            }

            point.mouseout = function(){
                Over_Objects = false;
            }

            point.click = point.tap = function(data){
                console.log("mousedown - " + this.number);
                if (Action == "DELETE")
                {
                    deleteNode(this.number);
                }
            }

            // use the mousedown and touchstart
            point.mousedown = point.touchstart = function(data)
            {
                stage.removeChild(this);
                stage.addChild(this);

                console.log("mousedown - " + this.number);
                // stop the default event...
                data.originalEvent.preventDefault();

                // store a reference to the data
                // The reason for this is because of multitouch
                // we want to track the movement of this particular touch
                this.data = data;
                this.dragging = true;

                if (Action === "MOVE"){
                    this.alpha = this.normalAlpha * 0.6;

                }else
                if (Action === "CREATE")
                {
                    Creating_Connection.is = true;
                    Creating_Connection.from = this.number;
                }
            };

            // set the events for when the mouse is released or a touch is released
            point.mouseupoutside = point.touchendoutside = 0;

            point.mouseup = point.touchend = function(data)
            {
                console.log("mouseup - " + this.number);
                CHANGED = true;
                this.alpha = this.normalAlpha;
                this.dragging = false;
                // set the interaction data to null
                this.data = null;

                if (Action === "CREATE")
                {
                    console.log("--");
                    console.log(Creating_Connection.is);
                    console.log(Creating_Connection.from);
                    console.log(this.number);


                    connect.set2D(Creating_Connection.from, this.number, 1);
                    points[Creating_Connection.from].dragging = false;
                    tempGrph.clear();
                    Creating_Connection.is = false;
                    
                }
            };

            // set the callbacks for when the mouse or a touch moves
            point.mousemove = point.touchmove = function(data)
            {
                if (this.dragging){
                    if (Action === "MOVE"){
                        
                        var newPosition = this.data.getLocalPosition(this.parent);
                        if (Use_Grid){
                            newPosition.x -= newPosition.x % gridDist; 
                            newPosition.y -= newPosition.y % gridDist;
                        }
                        this.position.x = newPosition.x;
                        this.position.y = newPosition.y;
                            

                    }else
                    if (Action === "CREATE" &&
                        Creating_Connection.is){

                        tempGrph.clear();
                        tempGrph.alpha = 0.4;
                        GeneralDrawing.drawArrow(tempGrph,
                                  new Vector(this.position.x, this.position.y), 
                                  new Vector(data.originalEvent.pageX, data.originalEvent.pageY));
                    }

                    CHANGED = true;
                }
            }
        }


        function Graph(elems)
        {
            var num     = elems; 
            this.tab2   = array2D(elems, elems);
            this.list1  = [];
            this.points = [];

            this.set2D = function(from, to, val)
            {
                this.tab2[from][to] = val; //1 or 0
                
                this.recalcList();
            }

            this.recalcList = function(){
                this.list1.length = 0;
                for (var i=0; i<num; ++i)
                for (var j=0; j<num; ++j)
                    if (this.tab2[i][j] === 1)
                        this.list1.push({from: i, to: j});
            }

            this.deleteElm = function(elem)
            {
                this.tab2.splice(elem, 1);
                for (var i=0; i<num-1; ++i)
                    this.tab2[i].splice(elem, 1);

                num--;

                this.recalcList();
            }

            if (num < 2)
                num = 2;
        }

        function DR_Point(color, posx, posy, num){
            var point;
            var sm_dim = WIDTH < HEIGHT ? WIDTH : HEIGHT;

            var tex = new PIXI.Graphics();
            tex.beginFill(color, 1);
            tex.drawCircle(100, 100, sm_dim * 0.06);
            tex.endFill();

            point = new PIXI.Sprite(tex.generateTexture());
            point.setInteractive(true);
            point.anchor.x = 
            point.anchor.y = 0.5;
            point.buttonMode = true;
            point.position.x = posx;
            point.position.y = posy;

            point.normalAlpha = 0.6;
            point.alpha = point.normalAlpha;

            point.number = num;
            setDragging(point);

            return point;
        }

        function array2D(rows, cols)
        {
            var t = new Array(rows);
            for (var i=0; i<rows; ++i)
            {
                t[i] = new Array(cols);
                for (var j=0; j<cols; ++j)
                    t[i][j] = 0;
            }
            return t;
        }

        function XGraph() {
            
        }


        function toPolarVectors(points){
            var ret = [];
            //vector from start point to end point
            var dir = new Vector(points[1].x-points[0].x, points[1].y-points[0].y);

            for (var i=0; i<points.length; ++i)
            {
                //vector from start point to point[i]
                var v = new Vector(points[i].x - points[0].x, points[i].y - points[0].y);
                //vector with dir as unit vector
                v.setPolar(v.rad / dir.rad, v.ang - dir.ang);
                ret.push(v);
            }
            return ret;   
        }
        
        function drawRecurLineCanvas(context, polVect, Svec, Fvec, lev, code)
        {
            if (code !== canvasCode)
                return;

            if (lev === 0 ||
                (Math.pow(Svec.x - Fvec.x, 2) + Math.pow(Svec.y - Fvec.y, 2)) 
                    < (MIN_LINE_DIST * MIN_LINE_DIST) //smaller than 1 pixel
                )
            {
                drawLine(Svec.x, Svec.y, Fvec.x, Fvec.y);
            }else
            if (lev > 0)
            {
                var dir = new Vector(Fvec.x - Svec.x, Fvec.y - Svec.y);

                var pNow = []; 

                for (var i=0; i<numPoints; ++i)
                {
                    var temp = new Vector(polVect[i].x, polVect[i].y);

                    temp.rad = temp.rad * dir.rad;
                    temp.ang = temp.ang + dir.ang;

                    temp.x = temp.x + Svec.x;
                    temp.y = temp.y + Svec.y;

                    pNow.push(temp);
                }

                for (var i=0; i<connect.list1.length; ++i)
                {
                    var x1 = pNow[ connect.list1[i].from ].x,
                        y1 = pNow[ connect.list1[i].from ].y,
                        x2 = pNow[ connect.list1[i].to ].x,
                        y2 = pNow[ connect.list1[i].to ].y;

                    if ((Math.pow(x1-x2, 2) + Math.pow(y1-y2, 2)) 
                            < (MIN_LINE_DIST * MIN_LINE_DIST))
                    {
                        drawLine(x1, y1, x2, y2);
                        continue;
                    }

                    if (code !== canvasCode) return;

                    setTimeout(function(i){
                        drawRecurLineCanvas(context, polVect, pNow[ connect.list1[i].from ], pNow[ connect.list1[i].to ], lev-1, code);
                    }, 1, i);
                }
            }

            function drawLine(x1, y1, x2, y2){
                context.beginPath();
                context.moveTo(x1, y1);
                context.lineTo(x2, y2);
                context.stroke();
            }
        }

        function animate() {
            requestAnimFrame( animate );
            
            renderer.render(stage);

            if (CHANGED){
                CHANGED = !CHANGED;

                if (Draw_Points_Lines)
                    GeneralDrawing.redrawArrows(linesGrph);

                canvasCode = Math.floor(Math.random()*1000000);

                var polVect = toPolarVectors(points);
                context.clearRect(0, 0, WIDTH, HEIGHT);
                drawRecurLineCanvas(context, polVect, new Vector(points[0].x, points[0].y), new Vector(points[1].x, points[1].y), recurLevel, canvasCode);
                lineSprite.setTexture(PIXI.Texture.fromCanvas(drawingCanvas));
            }            
        }
    }
    </script>
 
    </body>
</html>