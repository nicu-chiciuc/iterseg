<html>
<head>
    <title>FractaLine by Nicusor</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #000000;
        }
    </style>
    <script src="pixi.js"></script>
    <script src="utils.js"></script>
</head>
<body onload="startScript();">
    <script>
    function startScript() {
        "use strict";
        //the code below is very ugly, please read carefully

        var WIDTH  = window.innerWidth;
        var HEIGHT = window.innerHeight;

        var drawingCanvas = document.createElement('canvas');
        drawingCanvas.width  = WIDTH;
        drawingCanvas.height = HEIGHT;
        var context = drawingCanvas.getContext('2d');

        var stage = new PIXI.Stage(0xe0ffff, true);

        var renderer  = new PIXI.CanvasRenderer(WIDTH, HEIGHT, null, false, true);        

        var lineSprite = new PIXI.Sprite(PIXI.Texture.fromCanvas(drawingCanvas));
        stage.addChild(lineSprite);
        

        var linesGrph = new PIXI.Graphics();
        var gridGrph  = new PIXI.Graphics();
        var tempGrph  = new PIXI.Graphics();

        var recurLevel = 4;
        var numPoints  = 5; //including start and finish
        var L          = new LGraph(numPoints);

        var GRID_DIST = 20;
        var MIN_LINE_DIST = 3;

        //flags
        var Flag = {
            Use_Grid            : true,
            Over_Objects        : false,
            Creating_Connection : {is: false, from: -1},
            Draw_Points_Lines   : true,
            CHANGED             : true,
            Over_Buttons        : false,
            Show_Display        : true
        }

        var canvasCode;
        // var polVect;
         
        document.body.appendChild(renderer.view);

    
        
        stage.addChild(gridGrph);
        stage.addChild(tempGrph);
        stage.addChild(linesGrph);

        var text = new PIXI.Text("Recursion deepness: " + recurLevel, {font:"20px Arial", fill:"black"});
        stage.addChild(text);

        var about = new PIXI.Text("This is a very early version of the program\n \
there may be a lot of bugs\n \
press S and H to change to show or hide stuff\n \
press LEFT and RIGHT to increase/decrease recursion level",
            {font:"17px Arial", fill:"black"});
        stage.addChild(about);
        about.position.y = HEIGHT * 0.06;

        var GeneralDrawing = {
            //graph can be HTML5 canvas or PixiJS Graphics element
            drawGrid: function(graph, dist){
                graph.clear();
                graph.lineStyle(1, 0x111111, 0.2);

                var W = window.innerWidth;
                var H = window.innerHeight;
                var B = W > H ? W : H;

                for (var i=0; i<W; i+=dist)
                {

                    if (i % (dist * 5) == 0)
                        graph.lineStyle(2, 0x111111, 0.4);

                    graph.moveTo(0, i);
                    graph.lineTo(W, i);

                    graph.moveTo(i, 0);
                    graph.lineTo(i, H);

                    if (i % (dist * 5) == 0)
                        graph.lineStyle(1, 0x111111, 0.2);
                }
            },

            redrawArrows: function(graphics){
                if (!Flag.Show_Display) return;

                graphics.clear();
                graphics.alpha = 0.3;

                for (var i=0; i<L  .list1.length; ++i)
                    this.drawArrow(graphics, new Vector(points[ L  .list1[i].from ].x, points[ L  .list1[i].from ].y),
                                        new Vector(points[ L  .list1[i].to   ].x, points[ L  .list1[i].to   ].y));
                
            },

            drawArrow: function(graph, vec1, vec2){
                graph.beginFill();
                var dir = new Vector(vec2.x - vec1.x,
                                     vec2.y - vec1.y);

                var p1 = new Vector(0, 10);
                p1.ang += dir.ang + Math.PI/2;
                p1.x += vec1.x;
                p1.y += vec1.y;

                var p2 = new Vector(0, -10);
                p2.ang += dir.ang + Math.PI/2;
                p2.x += vec1.x;
                p2.y += vec1.y;

                var p3 = new Vector(vec2.x, vec2.y );

                graph.moveTo(p1.x, p1.y);
                graph.lineTo(p2.x, p2.y);
                graph.lineTo(p3.x, p3.y);

                graph.endFill();
            },
        }

        //not working as expected
        window.onresize = function(){
            WIDTH  = gridGrph.width  = drawingCanvas.width  = window.innerWidth;
            HEIGHT = gridGrph.height = drawingCanvas.height = window.innerHeight;
            renderer.resize(WIDTH, HEIGHT);
            GeneralDrawing.drawGrid(gridGrph, GRID_DIST);
        }

        GeneralDrawing.drawGrid(gridGrph, GRID_DIST);


        // all the points
        var points = new Array(L.num);
        points[0] = DR_Point(0x00ee00 , 100, 100, 0);
        points[1] = DR_Point(0xee0000, 1000, 100, 1);
        points[2] = DR_Point(0x000000, 400, 100 , 2);
        points[3] = DR_Point(0x000000, 550, 300 , 3);
        points[4] = DR_Point(0x000000, 700, 100 , 4);

        for (var i=0; i<L.num; i++)
            L.points[i] = points[i].position;

        console.log(L.num);
        for (var i=0; i<L.num; i++)
            stage.addChild(points[i]);
        // all the points

        L  .set2D(0, 2, 1);
        L  .set2D(2, 3, 1);
        L  .set2D(3, 4, 1);
        L  .set2D(4, 1, 1);

        requestAnimFrame( animate );

        function LStage() {
            this.resetRecurText = function(){
                text.setText("Recursion deepness:  " + recurLevel);
            }



        }   

        function resetRecurText(){
            text.setText("Recursion deepness:  " + recurLevel);
        }

        function increaseRecurLevel(){
            ++recurLevel ;
            resetRecurText();
        }

        function decreaseRecurLevel(){
            if (--recurLevel < 1)
                recurLevel = 1;
            resetRecurText();
        }

        function resetNumbers()
        {
            for (var i=0; i<numPoints; ++i)
                points[i].number = i;
        }

        //The Buttons
            var tempH = 300;
            var createButton = MyButton(PIXI.Texture.fromImage("res/createButton.png"), "CREATE", 0, tempH + 0);
            var moveButton   = MyButton(PIXI.Texture.fromImage("res/moveButton.png")  , "MOVE"  , 0, tempH + 40);
            var deleteButton = MyButton(PIXI.Texture.fromImage("res/deleteButton.png"), "DELETE", 0, tempH + 80);
            var demoButton   = new PIXI.Sprite(PIXI.Texture.fromImage('res/demo.png'));
            demoButton.interactive = true;
            demoButton.buttonMode  = true;
            demoButton.position = {x:0, y:tempH + 120};
            demoButton.click = function(){
                window.open('http://www.youtube.com/watch?v=Bc9IHxqa64c');
            }
            stage.addChild(demoButton);

            //var minusButton  = MyButton

            var allButtons = [createButton, moveButton, deleteButton];
            var Action = "MOVE"; //CREATE, DELETE

            moveButton.click();
            

            stage.addChild(createButton);
            stage.addChild(moveButton);
            stage.addChild(deleteButton);
        //The Buttons

        function MyButton(texture, action, posx, posy){
            var nowButton = new PIXI.Sprite(texture);
            nowButton.position = {x: posx, y: posy};
            nowButton.interactive = true;
            nowButton.buttonMode  = true;
            nowButton.act = action;


            nowButton.unclick = function(){
                nowButton.clicked = false;
                nowButton.alpha = 0.5;
            }

            nowButton.mouseover = function(){
                console.log("in button" + nowButton.act);
                Flag.Over_Buttons = true;
                Flag.Over_Objects = true;
                if (!this.clicked)
                    this.alpha = 0.7;
            }
            nowButton.click = nowButton.tap = function(){
                if (!this.clicked)
                {
                    for (var i=0; i<allButtons.length; ++i)
                        allButtons[i].unclick();

                    Action = this.act;
                    this.clicked = true;
                    this.alpha = 1;
                }
            }
            nowButton.mouseout = function(){
                console.log("out button" + nowButton.act);
                Flag.Over_Buttons = false;
                Flag.Over_Objects = false;
                if (!this.clicked)
                    this.alpha = 0.5;
            }

            nowButton.unclick();

            return nowButton;
        }

        stage.click = function(e){
            if (!Flag.Over_Objects)
            {
                if (Action === "CREATE")
                {
                    createNode(e.originalEvent.pageX, e.originalEvent.pageY);
                }
            }
        }

        document.onkeydown = function checkKey(e) {
            console.log(e.keyCode);

            e = e || window.event;

            if (e.keyCode == '72') {
                if (Flag.Use_Grid)
                {
                    Flag.Use_Grid = false
                    gridGrph.clear();
                }else{
                    GeneralDrawing.drawGrid(gridGrph, GRID_DIST);
                    Flag.Use_Grid = true;
                }
            }else
            if (e.keyCode == '32') {
                Flag.Draw_Points_Lines = !Flag.Draw_Points_Lines;
            }else
            if (e.keyCode == '39') {
                increaseRecurLevel();
                
                Flag.CHANGED = true;
            }else
            if (e.keyCode == '37') {
                decreaseRecurLevel();
                Flag.CHANGED = true;
            }else
            if (e.keyCode == '83') {
                showHideUI();
            }
        }

        function showHideUI(){
            var nowAlpha;
            Flag.Show_Display = !Flag.Show_Display;

            if (!Flag.Show_Display){
                nowAlpha = 0.01;
                linesGrph.clear();
            }
            else {
                nowAlpha = 0.6;
                GeneralDrawing.redrawArrows(linesGrph);
            }
            
                for (var i=0; i<points.length; ++i)
                {
                    points[i].normalAlpha = nowAlpha;
                    points[i].alpha = points[i].normalAlpha;

                }

        }

        function deleteNode(num){
            if (num > 1) { //if num is not start or end point
                L.deleteElm(num);
                stage.removeChild(points[num]);
                points.splice(num, 1);
                numPoints--;
                resetNumbers();
            }
        }

        function createNode(posx, posy){
            points.push(DR_Point(0x000000, posx, posy, numPoints));
            L.addNode(points[points.length-1].position);
            stage.addChild(points[numPoints]);
            numPoints++;
        }



        function setDragging(point) {

            point.mouseover = function(){
                Flag.Over_Objects = true;
            }

            point.mouseout = function(){
                Flag.Over_Objects = false;
            }

            point.click = point.tap = function(data){
                console.log("mousedown - " + this.number);
                if (Action == "DELETE")
                {
                    deleteNode(this.number);
                }
            }

            // use the mousedown and touchstart
            point.mousedown = point.touchstart = function(data)
            {
                stage.removeChild(this);
                stage.addChild(this);

                console.log("mousedown - " + this.number);
                // stop the default event...
                data.originalEvent.preventDefault();

                // store a reference to the data
                // The reason for this is because of multitouch
                // we want to track the movement of this particular touch
                this.data = data;
                this.dragging = true;

                if (Action === "MOVE"){
                    this.alpha = this.normalAlpha * 0.6;

                }else
                if (Action === "CREATE")
                {
                    Flag.Creating_Connection.is = true;
                    Flag.Creating_Connection.from = this.number;
                }
            };

            // set the events for when the mouse is released or a touch is released
            point.mouseupoutside = point.touchendoutside = 0;

            point.mouseup = point.touchend = function(data)
            {
                console.log("mouseup - " + this.number);
                Flag.CHANGED = true;
                this.alpha = this.normalAlpha;
                this.dragging = false;
                // set the interaction data to null
                this.data = null;

                if (Action === "CREATE")
                {
                    console.log("--");
                    console.log(Flag.Creating_Connection.is);
                    console.log(Flag.Creating_Connection.from);
                    console.log(this.number);


                    L.set2D(Flag.Creating_Connection.from, this.number, 1);
                    points[Flag.Creating_Connection.from].dragging = false;
                    tempGrph.clear();
                    Flag.Creating_Connection.is = false;
                    
                }
            };

            // set the callbacks for when the mouse or a touch moves
            point.mousemove = point.touchmove = function(data)
            {
                if (this.dragging){
                    if (Action === "MOVE"){
                        
                        var newPosition = this.data.getLocalPosition(this.parent);
                        if (Flag.Use_Grid){
                            newPosition.x -= newPosition.x % GRID_DIST; 
                            newPosition.y -= newPosition.y % GRID_DIST;
                        }
                        this.position.x = newPosition.x;
                        this.position.y = newPosition.y;
                            

                    }else
                    if (Action === "CREATE" &&
                        Flag.Creating_Connection.is){

                        tempGrph.clear();
                        tempGrph.alpha = 0.4;
                        GeneralDrawing.drawArrow(tempGrph,
                                  new Vector(this.position.x, this.position.y), 
                                  new Vector(data.originalEvent.pageX, data.originalEvent.pageY));
                    }

                    Flag.CHANGED = true;
                }
            }
        }

        function DR_Point(color, posx, posy, num){
            var point;
            var sm_dim = WIDTH < HEIGHT ? WIDTH : HEIGHT;

            var tex = new PIXI.Graphics();
            tex.beginFill(color, 1);
            tex.drawCircle(100, 100, sm_dim * 0.06);
            tex.endFill();

            point = new PIXI.Sprite(tex.generateTexture());
            point.setInteractive(true);
            point.anchor.x = 
            point.anchor.y = 0.5;
            point.buttonMode = true;
            point.position.x = posx;
            point.position.y = posy;

            point.normalAlpha = 0.6;
            point.alpha = point.normalAlpha;

            point.number = num;
            setDragging(point);

            return point;
        }

        function DPoints(){
        }

        function animate() {
            requestAnimFrame( animate );
            
            renderer.render(stage);

            if (Flag.CHANGED){
                Flag.CHANGED = !Flag.CHANGED;

                if (Flag.Draw_Points_Lines)
                    GeneralDrawing.redrawArrows(linesGrph);

                L.updateVectors();
                context.clearRect(0, 0, WIDTH, HEIGHT);
                L.drawRecurLineCanvas(context, recurLevel);
            }            
        }
    }
    </script>
 
    </body>
</html>